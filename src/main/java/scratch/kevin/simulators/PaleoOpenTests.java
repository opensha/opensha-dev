package scratch.kevin.simulators;

import java.awt.Color;
import java.io.File;
import java.io.IOException;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.math3.stat.StatUtils;
import org.dom4j.DocumentException;
import org.opensha.commons.data.CSVFile;
import org.opensha.commons.data.function.DiscretizedFunc;
import org.opensha.commons.data.function.EvenlyDiscretizedFunc;
import org.opensha.commons.geo.Location;
import org.opensha.commons.geo.LocationUtils;
import org.opensha.commons.gui.plot.GraphWindow;
import org.opensha.commons.gui.plot.PlotCurveCharacterstics;
import org.opensha.commons.gui.plot.PlotLineType;
import org.opensha.commons.gui.plot.PlotSpec;
import org.opensha.refFaultParamDb.vo.FaultSectionPrefData;
import org.opensha.sha.earthquake.faultSysSolution.FaultSystemRupSet;
import org.opensha.sha.earthquake.faultSysSolution.FaultSystemSolution;
import org.opensha.sha.earthquake.param.ProbabilityModelOptions;
import org.opensha.sha.earthquake.param.ProbabilityModelParam;
import org.opensha.sha.faultSurface.FaultSection;
import org.opensha.sha.simulators.SimulatorEvent;
import org.opensha.sha.simulators.SimulatorElement;
import org.opensha.sha.simulators.iden.ElementIden;
import org.opensha.sha.simulators.iden.LogicalAndRupIden;
import org.opensha.sha.simulators.iden.LogicalOrRupIden;
import org.opensha.sha.simulators.iden.RuptureIdentifier;
import org.opensha.sha.simulators.iden.SectionIDIden;
import org.opensha.sha.simulators.iden.SupraSeisRupIden;
import org.opensha.sha.simulators.parsers.EQSIMv06FileReader;
import org.opensha.sha.simulators.utils.General_EQSIM_Tools;

import scratch.UCERF3.analysis.FaultSysSolutionERF_Calc;
import scratch.UCERF3.erf.FaultSystemSolutionERF;
import scratch.UCERF3.logicTree.LogicalAndTrimmer;
import scratch.UCERF3.utils.U3FaultSystemIO;
import scratch.UCERF3.utils.paleoRateConstraints.PaleoProbabilityModel;
import scratch.UCERF3.utils.paleoRateConstraints.PaleoRateConstraint;
import scratch.UCERF3.utils.paleoRateConstraints.UCERF3_PaleoProbabilityModel;
import scratch.UCERF3.utils.paleoRateConstraints.UCERF3_PaleoRateConstraintFetcher;
import scratch.kevin.simulators.catBuild.RandomCatalogBuilder;
import scratch.kevin.simulators.dists.RandomDistType;

import com.google.common.base.Joiner;
import com.google.common.base.Preconditions;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;
import com.google.common.primitives.Doubles;

public class PaleoOpenTests {
	
	private static class OpenIntIden {
		protected RuptureIdentifier iden;
		protected String name;
		protected double oi;
		
		public OpenIntIden(RuptureIdentifier iden, String name, double oi) {
			this.iden = iden;
			this.name = name;
			this.oi = oi;
		}
	}
	
	private static class PaleoSite extends OpenIntIden {
		private Location loc;
		
		public PaleoSite(String name, Location loc, double oi, List<SimulatorElement> geom){
			this(getForLoc(name, loc, geom), name, loc, oi);
		}
		
		public PaleoSite(RuptureIdentifier iden, String name, Location loc, double oi) {
			super(iden, name, oi);
			this.loc = loc;
		}
		
		private static RuptureIdentifier getForLoc(String name, Location loc, List<SimulatorElement> geom) {
			if (geom == null)
				return null;
			SimulatorElement closest = null;
			double closestDist = Double.POSITIVE_INFINITY;
			
			for (SimulatorElement el : geom) {
				Location centerLocation = el.getCenterLocation();
				double hDist = LocationUtils.horzDistanceFast(loc, centerLocation);
				if (hDist < closestDist) {
					closestDist = hDist;
					closest = el;
				}
			}
			
			System.out.println("Mapped "+name+" to "+closest.getName()+" (hDist="+(float)closestDist+" km)"
					+"\t(depth="+(float)closest.getCenterLocation().getDepth()+" km)");
			return new ElementIden(name, closest.getID());
		}
	}
	
	private static List<PaleoSite> getJacksonData(List<SimulatorElement> geoms) {
		List<PaleoSite> sites = Lists.newArrayList();
		
		// this data is from Dave Jackson 1/30/2014 subject "Re: Can you send us your table?"
		sites.add(new PaleoSite("Calaveras_Fault-North", new Location(37.510, -121.835), 722d, geoms));
		sites.add(new PaleoSite("Elsinore-Glen_Ivy", new Location(33.770, -117.491), 102d, geoms));
		sites.add(new PaleoSite("Garlock-Western_(all_events)", new Location(34.987, -118.508), 330d, geoms));
		sites.add(new PaleoSite("Green_Valley-Mason_Road", new Location(38.234, -122.162), 407d, geoms));
		sites.add(new PaleoSite("Hayward_Fault-South", new Location(37.556, -121.974), 144d, geoms));
//		sites.add(new PaleoSite("Little_Salmon-Strong'sCreek", new Location(40.600, -124.122), 10890d, geoms));
//		sites.add(new PaleoSite("N._SAF-Santa_Cruz_Segment", new Location(36.963, -121.698), 106d, geoms));
		sites.add(new PaleoSite("Puente Hills", new Location(33.905, -118.110), 250d, geoms));
		sites.add(new PaleoSite("Rodgers_Creek", new Location(38.262, -122.533), 304d, geoms));
		sites.add(new PaleoSite("San_Jacinto-Hog_Lake", new Location(33.615, -116.709), 243d, geoms));
		sites.add(new PaleoSite("S.SAF-Wrightwood", new Location(34.370, -117.668), 156d, geoms));
		
		return sites;
	}
	
	private static List<OpenIntIden> getMajorFaultData(List<SimulatorElement> geoms) {
		List<OpenIntIden> faults = Lists.newArrayList();
		
		faults.add(new OpenIntIden(SectionIDIden.getALLCAL2_SSAF(geoms), "S. SAF", 156));
		faults.add(new OpenIntIden(SectionIDIden.getALLCAL2_NSAF(geoms), "N. SAF", 108));
		
		return faults;
	}
	
	private static void resetOIsIfAbove(List<? extends OpenIntIden> sites, double maxOI) {
		for (OpenIntIden site : sites)
			if (site.oi > maxOI)
				site.oi = maxOI;
	}
	
	private static double calcFractTimeInWindow(double catStartTime, double catEndTime,
			List<double[]> idenEventTimes, List<Double> idenOIs) {
		int timesInWindows = 0;
		int timeSteps = 0;
		
		timeLoop:
		for (double time=catStartTime+100d; time<catEndTime; time += 1d) {
//			if (loopCnt % 10000 == 0)
//				System.out.println("Loop "+loopCnt+"/"+expected);
//			loopCnt++;
			
			boolean match = true;
			for (int i=0; i<idenEventTimes.size(); i++) {
				double[] times = idenEventTimes.get(i);
				int bin = Arrays.binarySearch(times, time);
				double eventTime;
				if (bin >= 0) {
					eventTime = times[bin];
				} else {
					int insertionPoint = -(bin + 1);
					if (insertionPoint == 0)
						// this means we're before the first event
						continue timeLoop;
					eventTime = times[insertionPoint-1];
				}
				double oi = time - eventTime;
//				if (loopCnt % 10000 == 0) 
//					System.out.println("Debug! time="+time+"\teTime="+eventTime
//							+"\toi="+oi+"\tdataOI="+openIntervals.get(i));
				if (oi < idenOIs.get(i)) {
					match = false;
					break;
				}
			}
			timeSteps++;
			
			if (match)
				timesInWindows++;
		}
		
		double fract = (double)timesInWindows/(double)timeSteps;
		
		System.out.println(timesInWindows+"/"+timeSteps+" ("+(float)(fract*100)+" %) match data");
		
		return fract;
	}
	
	private static List<double[]> calcIdenEventTimes(List<? extends SimulatorEvent> events, List<RuptureIdentifier> idens) {
		List<double[]> idenEventTimes = Lists.newArrayList();
		for (int i=0; i<idens.size(); i++) {
			List<? extends SimulatorEvent> matches = idens.get(i).getMatches(events);
			double[] times = new double[matches.size()];
			for (int j=0; j<matches.size(); j++)
				times[j] = matches.get(j).getTimeInYears();
			idenEventTimes.add(times);
		}
		return idenEventTimes;
	}
	
	private static void writeSites(List<? extends OpenIntIden> sites, File file) throws IOException {
		CSVFile<String> csv = new CSVFile<String>(true);
		
		csv.addLine("Name", "Open Interval (yr)", "Element ID");
		
		for (OpenIntIden site : sites) {
			Preconditions.checkState(site.iden instanceof ElementIden, "can only write for element idens");
			String elemStr = Joiner.on(",").join(((ElementIden)site.iden).getElementIDs());
			csv.addLine(site.name, site.oi+"", elemStr);
		}
		
		csv.writeToFile(file);
	}
	
	private static void makeUCERF3OpenVsMeanRIPlot() throws IOException, DocumentException {
		List<PaleoSite> ois = getJacksonData(null);
		FaultSystemSolution baSol = U3FaultSystemIO.loadSol(new File("/home/kevin/workspace/OpenSHA/dev/"
				+ "scratch/UCERF3/data/scratch/InversionSolutions/"
				+ "2013_05_10-ucerf3p3-production-10runs_COMPOUND_SOL_FM3_1_MEAN_BRANCH_AVG_SOL.zip"));
		
	}
	
	private static final Color[] colors = {Color.BLACK, Color.GRAY, Color.BLUE};
	
	public static void main(String[] args) throws IOException, DocumentException {
		File dir = new File("/home/kevin/Simulators");
		File geomFile = new File(dir, "ALLCAL2_1-7-11_Geometry.dat");
		System.out.println("Loading geometry...");
		General_EQSIM_Tools tools = new General_EQSIM_Tools(geomFile);
		List<SimulatorElement> geoms = tools.getElementsList();
		
//		HashSet<String> faults = new HashSet<String>();
//		DecimalFormat df = new DecimalFormat("000");
//		for (RectangularElement elem : geoms)
//			faults.add(df.format(elem.getFaultID())+". "+elem.getSectionName());
//		List<String> faultsSorted = Lists.newArrayList(faults);
//		Collections.sort(faultsSorted);
//		for (String name : faultsSorted)
//			System.out.println(name);
//		System.exit(0);
		
		List<? extends OpenIntIden> sites = getJacksonData(geoms);
		writeSites(sites, new File("/tmp/paleo_sites.csv"));
//		System.exit(0);
		
//		List<? extends OpenIntIden> sites = getMajorFaultData(geoms);
		
		boolean doRand = true;
		boolean randSplitMultis = false;
		boolean doPowerSetSearch = false;
		boolean doOIFuncGraph = false;
		boolean doUCERF3Calcs = true;
		
//		resetOIsIfAbove(sites, 156);
		
		List<RuptureIdentifier> idens = Lists.newArrayList();
		for (OpenIntIden site : sites)
			idens.add(site.iden);
		
		boolean supraSeismo = true;
		
		File eventFile = new File(dir, "eqs.ALLCAL2_RSQSim_sigma0.5-5_b=0.015.long.barall");
		
		System.out.println("Loading events...");
		List<? extends SimulatorEvent> events;
		if (supraSeismo) {
			RuptureIdentifier supraSeismoIden = new SupraSeisRupIden(tools);
			RuptureIdentifier andIden = new LogicalAndRupIden(supraSeismoIden, new LogicalOrRupIden(idens));
			events = EQSIMv06FileReader.readEventsFile(eventFile, geoms, Lists.newArrayList(andIden));
//			events = EQSIMv06FileReader.readEventsFile(eventFile, geoms, Lists.newArrayList(supraSeismoIden));
		} else {
			events = EQSIMv06FileReader.readEventsFile(eventFile, geoms, idens);
		}
		Preconditions.checkState(!events.isEmpty());
		RandomDistType[] randTypes;
		if (doRand)
			randTypes = new RandomDistType[] { null, RandomDistType.PROBABILISTIC_SHUFFLE, RandomDistType.ACTUAL };
		else
			randTypes = new RandomDistType[] { null };
		List<List<? extends SimulatorEvent>> eventLists = Lists.newArrayList();
		for (RandomDistType randType : randTypes) {
			if (randType == null)
				eventLists.add(events);
			else
				eventLists.add(RandomCatalogBuilder.getRandomResampledCatalog(
						events, idens, randType, randSplitMultis));
		}
		
		if (doPowerSetSearch) {
			List<List<List<Double>>> allFracts = Lists.newArrayList();
			for (int r=0; r<randTypes.length; r++) {
				RandomDistType randType = randTypes[r];
				List<? extends SimulatorEvent> myEvents = eventLists.get(r);
//			}
//			for (boolean random : randoms) {
//				List<EQSIM_Event> myEvents;
//				if (random)
//					myEvents = randEvents;
//				else
//					myEvents = events;
				
				List<double[]> idenEventTimes = calcIdenEventTimes(myEvents, idens);
				
				double catStartTime = myEvents.get(0).getTimeInYears();
				double catEndTime = myEvents.get(myEvents.size()-1).getTimeInYears();
				
				// indexed to set size - 1
				List<List<Double>> myFracts = Lists.newArrayList();
				for (int i=0; i<sites.size(); i++)
					myFracts.add(new ArrayList<Double>());
				
				allFracts.add(myFracts);
				
				HashSet<Integer> indexesList = new HashSet<Integer>();
				for (int i=0; i<sites.size(); i++)
					indexesList.add(i);
				
				HashSet<String> nevers = new HashSet<String>();
				
				List<Set<Integer>> biggestSets = null;
				int biggestSetNum = -1;
				
				for (Set<Integer> indexesSet : Sets.powerSet(indexesList)) {
					if (indexesSet.isEmpty())
						continue; // need at least one 
					System.out.println("Set: "+Joiner.on(",").join(indexesSet));
					List<double[]> subIdenEventTimes = Lists.newArrayList();
					List<Double> subOpenIntervals = Lists.newArrayList();
					for (int index : indexesSet) {
						subIdenEventTimes.add(idenEventTimes.get(index));
						subOpenIntervals.add(sites.get(index).oi);
					}
					
					double fract = calcFractTimeInWindow(catStartTime, catEndTime, subIdenEventTimes, subOpenIntervals);
					
					myFracts.get(indexesSet.size()-1).add(fract);
					
					if (fract > 0d) {
						if (indexesSet.size() > biggestSetNum) {
							biggestSets = Lists.newArrayList();
							biggestSetNum = indexesSet.size();
						}
						if (biggestSetNum == indexesSet.size())
							biggestSets.add(indexesSet);
					}
					
					if (indexesSet.size() == 1 && fract == 0d)
						nevers.add(sites.get(indexesSet.iterator().next()).name);
				}
				
				for (String never : nevers)
					System.out.println("NEVER found a match for: "+never);
				
				List<List<String>> biggestIncludes = Lists.newArrayList();
				List<List<String>> biggestExcludes = Lists.newArrayList();
				
				for (Set<Integer> set : biggestSets) {
					List<String> includeNames = Lists.newArrayList();
					List<String> excludeNames = Lists.newArrayList();
					
					for (int i=0; i<sites.size(); i++) {
						String name = sites.get(i).name;
						if (set.contains(i))
							includeNames.add(name);
						else
							excludeNames.add(name);
					}
					biggestIncludes.add(includeNames);
					biggestExcludes.add(excludeNames);
				}
				
				System.out.println("Biggest with a match was "+biggestSetNum+" long:");
				for (int i=0; i<biggestSets.size(); i++)
					System.out.println("\tIncluded: "+Joiner.on(",").join(biggestIncludes.get(i))
							+"\tExcluded: "+Joiner.on(",").join(biggestExcludes.get(i)));
			}
			
			// now make plots
			plotSetFractData(Lists.newArrayList(randTypes), allFracts);
		}
		
		if (doOIFuncGraph) {
			double minOI = 5d;
			int numOI = 60;
			double deltaOI = 5d;
			
			List<double[]> idenEventTimes = null;
			List<double[]> randIdenEventTimes = null;
			List<List<double[]>> allEventTimes = Lists.newArrayList();
			for (int r=0; r<randTypes.length; r++) {
				RandomDistType randType = randTypes[r];
				List<? extends SimulatorEvent> myEvents = eventLists.get(r);
//			for (boolean random : randoms) {
//				List<EQSIM_Event> myEvents;
//				if (random)
//					myEvents = randEvents;
//				else
//					myEvents = events;
				
				List<double[]> myIdenEventTimes = calcIdenEventTimes(myEvents, idens);
				allEventTimes.add(myIdenEventTimes);
				
//				double startTime = myEvents.get(0).getTimeInYears();
//				double endTime = myEvents.get(myEvents.size()-1).getTimeInYears();
//				
//				if (random) {
//					randStartTime = startTime;
//					randEndTime = endTime;
//					randIdenEventTimes = myIdenEventTimes;
//				} else {
//					catStartTime = startTime;
//					catEndTime = endTime;
//					idenEventTimes = myIdenEventTimes;
//				}
			}
			List<List<Integer>> subSiteIndexesLists = Lists.newArrayList();
			List<String> names = Lists.newArrayList();
			List<Integer> allSitesIndexesList = Lists.newArrayList();
			for (int i=0; i<sites.size(); i++) {
				OpenIntIden site = sites.get(i);
				subSiteIndexesLists.add(Lists.newArrayList(i));
				names.add(site.name);
				allSitesIndexesList.add(i);
			}
			if (sites.size() > 1) {
				subSiteIndexesLists.add(allSitesIndexesList);
				names.add("All Sites");
			}
			for (int j = 0; j < subSiteIndexesLists.size(); j++) {
				List<Integer> subSiteIndexes = subSiteIndexesLists.get(j);
				List<EvenlyDiscretizedFunc> oiFuncs = Lists.newArrayList();
				
//				for (boolean random : randoms) {
				for (int r=0; r<randTypes.length; r++) {
					RandomDistType randType = randTypes[r];
					List<? extends SimulatorEvent> myEvents = eventLists.get(r);
					EvenlyDiscretizedFunc func = new EvenlyDiscretizedFunc(minOI, numOI, deltaOI);
					double startTime = myEvents.get(0).getTimeInYears();
					double endTime = myEvents.get(myEvents.size()-1).getTimeInYears();
					List<double[]> myIdenEventTimes = allEventTimes.get(r);
					oiFuncs.add(func);
					
//					if (random) {
//						randOIFunc = func;
//						startTime = randStartTime;
//						endTime = randEndTime;
//						myIdenEventTimes = randIdenEventTimes;
//					} else {
//						oiFunc = func;
//						startTime = catStartTime;
//						endTime = catEndTime;
//						myIdenEventTimes = idenEventTimes;
//					}
					
					List<double[]> subIdenEvenTimes = Lists.newArrayList();
					for (int index : subSiteIndexes)
						subIdenEvenTimes.add(myIdenEventTimes.get(index));
					
					for (int i=0; i<numOI; i++) {
						double oi = func.getX(i);
						
						List<Double> ois = Lists.newArrayList();
						for (int index : subSiteIndexes) {
							sites.get(index).oi = oi;
							ois.add(oi);
						}
						
						double fract = calcFractTimeInWindow(startTime, endTime, subIdenEvenTimes, ois);
						
						func.set(i, fract);
					}
				}
				
				List<DiscretizedFunc> funcs = Lists.newArrayList();
				List<PlotCurveCharacterstics> chars = Lists.newArrayList();
				
				for (int r=0; r<oiFuncs.size(); r++) {
					EvenlyDiscretizedFunc oiFunc = oiFuncs.get(r);
					funcs.add(oiFunc);
					RandomDistType type = randTypes[r];
					float size;
					if (type == null) {
						oiFunc.setName("RSQSim");
						size = 4f;
					} else {
						oiFunc.setName(type.getName());
						size = 2f;
					}
					chars.add(new PlotCurveCharacterstics(PlotLineType.SOLID, size, colors[r]));
				}
//				funcs.add(oiFunc);
//				oiFunc.setName("RSQSim");
//				chars.add(new PlotCurveCharacterstics(PlotLineType.SOLID, 4f, Color.BLACK));
//				if (randOIFunc != null) {
//					funcs.add(randOIFunc);
//					randOIFunc.setName("Randomized");
//					chars.add(new PlotCurveCharacterstics(PlotLineType.DASHED, 2f, Color.GRAY));
//				}
				
				PlotSpec spec = new PlotSpec(funcs, chars, names.get(j), "Open Interval (years)",
						"Fract Time In Matching Window");
				spec.setLegendVisible(true);
				
				new GraphWindow(spec);
			}
		}
		
		// now 1910 comparison
//		double startYear = 1910; // REMEMBER TO RE-ENABLE N.SAF
//		long startYearInMillis = -1893427200000l;
		double startYear = 1875; // REMEMBER TO DISABLE N.SAF
		long startYearInMillis = -2997878400000l;
		double curYear = 2014;
		double duration = curYear-startYear;
		double oi = curYear-startYear;
		List<Double> ois = Lists.newArrayList();
		for (OpenIntIden site : sites) {
			site.oi = oi;
			ois.add(oi);
		}
		
		for (int r=0; r<randTypes.length; r++) {
			RandomDistType randType = randTypes[r];
			List<? extends SimulatorEvent> myEvents = eventLists.get(r);
			
			List<double[]> myIdenEventTimes = calcIdenEventTimes(myEvents, idens);
			double startTime = myEvents.get(0).getTimeInYears();
			double endTime = myEvents.get(myEvents.size()-1).getTimeInYears();
			
			double fract = calcFractTimeInWindow(startTime, endTime, myIdenEventTimes, ois);
			System.out.println("RSQSim ("+randType+") survival fract from "+1910+": "+fract);
		}
		
//		List<double[]> myIdenEventTimes = calcIdenEventTimes(events, idens);
//		double startTime = events.get(0).getTimeInYears();
//		double endTime = events.get(events.size()-1).getTimeInYears();
//		
//		double fract = calcFractTimeInWindow(startTime, endTime, myIdenEventTimes, ois);
//		System.out.println("RSQSim survival fract from "+1910+": "+fract);
//		
//		// now do randomized
//		if (doRand) {
//			myIdenEventTimes = calcIdenEventTimes(randEvents, idens);
//			startTime = randEvents.get(0).getTimeInYears();
//			endTime = randEvents.get(randEvents.size()-1).getTimeInYears();
//			
//			double randFract = calcFractTimeInWindow(startTime, endTime, myIdenEventTimes, ois);
//			System.out.println("RSQSim randomized survival fract from "+1910+": "+randFract);
//		}
		
		// now UCERF3
		if (doUCERF3Calcs) {
			FaultSystemSolution fss = U3FaultSystemIO.loadSol(new File("/home/kevin/workspace/OpenSHA/dev/"
					+ "scratch/UCERF3/data/scratch/InversionSolutions/"
					+ "2013_05_10-ucerf3p3-production-10runs_COMPOUND_SOL_FM3_1_MEAN_BRANCH_AVG_SOL.zip"));
			FaultSystemRupSet rupSet = fss.getRupSet();
			for (FaultSection sect : rupSet.getFaultSectionDataList()) {
				if (sect.getDateOfLastEvent() > startYearInMillis) {
					System.out.println("Clearing date last event on "+sect.getParentSectionName());
					sect.setDateOfLastEvent(Long.MIN_VALUE);
				}
			}
			PaleoProbabilityModel paleoProbModel = UCERF3_PaleoProbabilityModel.load();
			ArrayList<PaleoRateConstraint> ucerf3Constr = UCERF3_PaleoRateConstraintFetcher.getConstraints(
					rupSet.getFaultSectionDataList());
			ProbabilityModelOptions[] probModels = {ProbabilityModelOptions.U3_PREF_BLEND, ProbabilityModelOptions.POISSON};
			FaultSystemSolutionERF erf = new FaultSystemSolutionERF(fss);
			for (ProbabilityModelOptions probModel : probModels) {
				erf.setParameter(ProbabilityModelParam.NAME, probModel);
				if (probModel != ProbabilityModelOptions.POISSON)
					erf.getTimeSpan().setStartTime((int)startYear);
				erf.getTimeSpan().setDuration(duration);
				if (probModel != ProbabilityModelOptions.POISSON)
					Preconditions.checkState(erf.getTimeSpan().getStartTimeYear() == (int)startYear);
				erf.updateForecast();
				List<Integer> constrIndexes = Lists.newArrayList();
				for (OpenIntIden site : sites) {
					Preconditions.checkState(site instanceof PaleoSite);
					Location loc = ((PaleoSite)site).loc;
					double minDist = Double.POSITIVE_INFINITY;
					int closestSect = -1;
					for (PaleoRateConstraint constr : ucerf3Constr) {
						double dist = LocationUtils.horzDistanceFast(loc, constr.getPaleoSiteLoction());
						if (dist < minDist) {
							minDist = dist;
							closestSect = constr.getSectionIndex();
						}
					}
					Preconditions.checkState(minDist < 10d);
					constrIndexes.add(closestSect);
				}
//				List<Double> paleoVisiblePartProbs = Lists.newArrayList();
				double multProbs = 1;
				double sumRate = 0d;
				double sumRatePaleoProb = 0d;
				Map<Integer, List<Integer>> sectsForRups = Maps.newHashMap();
				HashSet<Integer> rups = new HashSet<Integer>();
				int numDuplicates = 0;
				int total = 0;
				for (int sectIndex : constrIndexes) {
					List<Integer> myRups = rupSet.getRupturesForSection(sectIndex);
					for (int rup : myRups) {
						List<Integer> sects = sectsForRups.get(rup);
						if (sects == null) {
							sects = Lists.newArrayList();
							sectsForRups.put(rup, sects);
						}
						sects.add(sectIndex);
						total++;
						if (rups.contains(rup))
							numDuplicates++;
						rups.add(rup);
					}
				}
				System.out.println(numDuplicates+"/"+total+" duplicates!");
				List<Double> rupProbs = Lists.newArrayList();
				for (int rup : rups) {
					int sourceID = erf.getSrcIndexForFltSysRup(rup);
					if (sourceID < 0) {
//						Preconditions.checkState(fss.getRateForRup(rup) == 0);
						continue;
					}
					double rate = erf.getSource(sourceID).computeTotalEquivMeanAnnualRate(duration)*duration;
					rupProbs.add(erf.getSource(sourceID).computeTotalProb());
					sumRate += rate;
					List<Double> paleoProbs = Lists.newArrayList();
					for (int sectIndex : sectsForRups.get(rup))
						paleoProbs.add(paleoProbModel.getProbPaleoVisible(rupSet, rup, sectIndex));
					double paleoProb;
					if (paleoProbs.size() == 1)
						paleoProb = paleoProbs.get(0);
					else
						paleoProb = FaultSysSolutionERF_Calc.calcSummedProbs(paleoProbs);
					sumRatePaleoProb += rate*paleoProb;
				}
				double probNot = (Math.exp(-sumRate));
				System.out.println("UCERF3 "+probModel.name()+" rate="+sumRate+", prob none: "+probNot);
//				double paleoProbNot = (Math.exp(-sumRatePaleoProb));
//				System.out.println("UCERF3 "+probModel.name()+" PALEO rate="+sumRatePaleoProb+", prob none: "+paleoProbNot);
				// now calculate from the individual probs
				System.out.println("UCERF3 "+probModel.name()+" prob none from summed probs: "
						+(1-FaultSysSolutionERF_Calc.calcSummedProbs(rupProbs)));
				
//				for (int sectIndex : constrIndexes) {
//					List<Integer> rups = rupSet.getRupturesForSection(sectIndex);
//					List<Double> subProbs = Lists.newArrayList();
//					for (int rup : rups) {
////						Preconditions.checkState(!rupsSoFar.contains(rup));
//						rupsSoFar.add(rup);
//						sumRate += fss.getRateForRup(rup);
//						int sourceID = erf.getSrcIndexForFltSysRup(rup);
//						if (sourceID < 0)
//							continue;
//						double prob = erf.getSource(sourceID).computeTotalProb();
//						prob *= paleoProbModel.getProbPaleoVisible(rupSet, rup, sectIndex);
//						subProbs.add(prob);
//					}
//					double prob = FaultSysSolutionERF_Calc.calcSummedProbs(subProbs);
//					multProbs *= (1-prob); // we want probability of this NOT happening
//					paleoVisiblePartProbs.add(prob);
//				}
//				System.out.println("UCERF3 "+probModel.name()+" prob: "+multProbs);
//				System.out.println("Sum rate: "+sumRate+", prob none: "+(Math.exp(-sumRate*(curYear-startYear))));
			}
		}
	}
	
	private static void plotSetFractData(List<RandomDistType> randTypes, List<List<List<Double>>> datasList) { 
		
		List<DiscretizedFunc> funcs = Lists.newArrayList();
		List<PlotCurveCharacterstics> chars = Lists.newArrayList();
		
		for (int r=0; r<randTypes.size(); r++) {
			RandomDistType randType = randTypes.get(r);
			List<List<Double>> datas = datasList.get(r);
			
			EvenlyDiscretizedFunc minFunc = new EvenlyDiscretizedFunc(1d, datas.size(), 1d);
			EvenlyDiscretizedFunc maxFunc = new EvenlyDiscretizedFunc(1d, datas.size(), 1d);
			EvenlyDiscretizedFunc meanFunc = new EvenlyDiscretizedFunc(1d, datas.size(), 1d);
			
			for (int i=0; i<datas.size(); i++) {
				double[] vals = Doubles.toArray(datas.get(i));
				minFunc.set(i, StatUtils.min(vals));
				maxFunc.set(i, StatUtils.max(vals));
				meanFunc.set(i, StatUtils.mean(vals));
			}
			
			Color c = colors[r];
			float size;
			if (randType == null)
				size = 4f;
			else
				size = 2f;
			
			funcs.add(minFunc);
			chars.add(new PlotCurveCharacterstics(PlotLineType.SOLID, 1f, c));
			funcs.add(maxFunc);
			chars.add(new PlotCurveCharacterstics(PlotLineType.SOLID, 1f, c));
			funcs.add(meanFunc);
			chars.add(new PlotCurveCharacterstics(PlotLineType.SOLID, size, c));
		}
		
		PlotSpec spec = new PlotSpec(funcs, chars, "Sim/Data Open Interval Search", "Num Paleo Sites",
				"Fract Time In Matching Window");
		
		new GraphWindow(spec);
	}

}
